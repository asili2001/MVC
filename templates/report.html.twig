{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <div class="content">
        <h1>Report</h1>
        <div class="report">
            <div class="btns">
                <a href="#kmom01" alt="kmom01" class="btn">Kmom01</a>
                <a href="#kmom02" alt="kmom02" class="btn">Kmom02</a>
                <a href="#kmom03" alt="kmom03" class="btn">Kmom03</a>
                <a href="#kmom04" alt="kmom04" class="btn">Kmom04</a>
                <a href="#kmom05" alt="kmom05" class="btn">Kmom05</a>
                <a href="#kmom06" alt="kmom06" class="btn">Kmom06</a>
                <a href="#kmom10" alt="kmom10" class="btn">Kmom10</a>
            </div>
            <div class="report-list">
                <div class="item" id="kmom01">
                    <h2>Kmom01</h2>
                    <p>
                        I KMOM01 fick vi börja använda Symfony, vilket är ett PHP-ramverk som följer en modell-visning-kontroll (MVC)-arkitektur.
                        <br><br>
                        Tidigare har jag arbetat med MVC i PHP och skapat en app-skeleton från scratch, vilket finns i min GitHub-repo.
                        Däremot har jag inte använt Symfony tidigare.
                        <br><br>
                        Kodstrukturen är väldigt användarvänlig, men jag anser att Symfony gör det ännu enklare att skapa applikationer med bra struktur,
                        vilket kan upplevas som en nackdel då man inte nödvändigtvis förstår vad som händer bakom kulisserna.
                        <br><br>
                        Personligen föredrar jag att förstå vad jag sysslar med innan jag använder ett ramverk och skulle därför föredra att köra "vanilla PHP", 
                        vilket gör att man förstår allt man gör.
                        <br><br>
                        Det som intresserade mig mest i artikeln "PHP The Right Way" var delen om "Web Application Security".
                        <br><br>
                        Det är mycket viktigt med säkerhet i en webbapplikation eftersom det finns personer som är redo att hacka in i din applikation.
                        <br><br>
                        Min TIL för detta kursmoment är att jag har fått testa på Symfony.

                    </p>
                </div>
                <div class="item" id="kmom02">
                    <h2>Kmom02</h2>
                    <p>
                        I kmom02 har vi lärt oss arv, komposition, interface och trait. Arv (engelska: "inheritance") används när man vill ärva egenskaper (properties) och metoder (methods) från en överordnad (base/parent) klass. Till exempel kan "PaymentMethod" vara en överordnad klass och "Swish" en underordnad (child) klass som ärver funktioner från sin överordnade klass.
                        <br><br>
                        Komposition (engelska: "composition") är när en klass använder en annan klass som en del av sin egen funktionalitet.
                        <br><br>
                        Ett interface definierar en uppsättning metoder och egenskaper som en klass som implementerar interfacet måste ha. Ett interface fungerar som en slags ritning eller mall över hur en klass ska se ut och vilka metoder som den ska innehålla. När en klass implementerar ett interface, måste den implementera alla metoder som definieras i interfacet.
                        <br><br>
                        Ett trait är i princip ett återanvändbart kodblock som kan inkluderas i en eller flera klasser. När en klass använder ett trait, införlivas kodblocket i klassen och dess funktioner och egenskaper blir tillgängliga för klassen. På så sätt kan man undvika upprepning av kod och uppnå högre modularitet i koden.
                        <br><br>
                        I min implementation har jag använt mig av olika objektorienterade tekniker för att skapa en fungerande kod. För att åstadkomma en enhetlig struktur på alla returdata från API:et använde jag mig av ett trait som heter "Returner". Detta trait inkluderar en funktion som heter "ArrReturner" som används för att skapa en enhetlig struktur på data som ska returneras.
                        <br><br><br>
                        Jag använde också komposition i både "DeckOfCards" och "HandOfCards"-klasserna. Detta innebär att jag inkluderade en instans av en annan klass inuti dessa klasser för att återanvända funktionalitet.
                        <br><br>
                        I klassen "CardGraphic" använde jag mig av arv för att ärva funktionalitet från klassen "Card".
                        <br><br>
                        Jag implementerade också Custom Exceptions för att hantera eventuella fel som kan uppstå i koden och arbetade med hur man kan hantera dessa på ett korrekt sätt.
                        <br><br>
                        Jag är nöjd med hur jag har kunnat tillämpa det jag har lärt mig och mer i kursmoment 02, men jag är medveten om att min webbplats kan förbättras med en bättre design, vilket jag hoppas kunna ta itu med i framtiden.
                        <br><br><br>
                        Jag löste uppgiften utan att använda pseudokod. I stället började jag med att planera och organisera koden genom att bryta ner problemet i mindre delar och skapa en övergripande struktur för min applikation samt rita ett UML diagram. Jag fokuserade på att skriva ren, lättläst och välstrukturerad kod för att göra det lättare att förstå och underhålla koden i framtiden.
                        <br><br>
                        Min TIL är att jag fick träna på de objektorienterade konstruktionerna samt implementera de i min kod.


                    </p>
                </div>
                <div class="item" id="kmom03">
                    <h2>Kmom03</h2>
                    <p>
                        I kmom03 har vi fortsatt att jobba med klasser genom att skapa ett blackjackspel med hjälp av lek kort klasserna från föregående kursmoment.
                        <br>
                        Jag ritade upp ett flödesdiagram och tyckte att det var en enkel uppgift som inte krävde pseudokod. 
                        <br>
                        Jag anser att pseudokod inte är viktig för enkelare projekt, utan främst användbart för mer avancerade projekt för att underlätta förståelsen av hur applikationen ska fungera.
                        <br>
                        I mitt fall designar jag vanligtvis applikationen först för att förstå dess funktionalitet.
                        <br><br>
                        Jag har skapat en klass vid namn "blackjackhand" som använder metoder som ärver från "cardhand".
                        <br>
                        "getPoints()" metoden finns inom "blackjackhand" och räknar ut poängen för korten i handen.
                        <br>
                        Efter jag skapade applikationen och skulle göra API insåg jag att koden i appen och API:n nästan var identisk, enda skillnaden var sättet datan skulle returneras på.
                        <br>
                        Därför skapade jag "cardgamefuncs" klassen för att samla alla blackjackfunktioner och använde sedan denna klass i både API och appen (komposition) för att följa DRY-regeln. Jag är väldigt nöjd med hur implementationen blev.
                        <br><br>
                        Personligen har jag inte märkt någon stor skillnad mellan att använda Symfony och att använda vanilla PHP.
                        <br>
                        De funktioner som finns tillgängliga i Symfony kan enkelt skapas eller användas som bibliotek i vanilla PHP.
                        <br>
                        Eftersom vi bara är i kmom03 just nu, finns det möjlighet att vi kommer att lära oss mer om Symfony i de framtida kurserna.
                        <br><br>
                        Mitt TIL för idag att träna på flödesdiagram samt psuedokod. Jag kommer definitivt använda när det behövs.
                    </p>
                </div>
                <div class="item" id="kmom04">
                    <h2>Kmom04</h2>
                    <p>
                        I kursmoment 4 övade vi på att testa de klasser som vi skapat i tidigare moment.
                        <br>
                        Att testa koden är viktigt och det är bra att tänka på att skriva klasser som inte är kopplade till sessionen, till exempel.
                        <br>
                        För mig innebar det inte mycket ändringar. Alla tester jag skrev fungerade som de skulle utan några kodändringar.
                        <br>
                        Jag fick 99,26% kodtäckning.
                        <br><br>
                        Att skriva testbar kod innebär att man själv och andra kan förstå koden bättre och lättare samt att man lättare kan identifiera buggar.
                        <br><br>
                        Min TIL för detta kursmoment är att jag lärde mig hur phpunit fungerar.
                        <br>
                        Jag kommer definitivt att använda detta i mina framtida php-projekt.

                    </p>
                </div>
                <div class="item" id="kmom05">
                    <h2>Kmom05</h2>
                    <p>
                        I detta kursmoment fick vi arbeta med Doctrine, ett ORM-verktyg för att hantera databaser på ett objektorienterat sätt.
                        <br>
                        Att jobba med Doctrine kändes lätt men man behöver träna mycket på det så det fastnar i huvudet.
                        <br>
                        Min library som jag byggde har alla böcker i root. Annars fick jag följa instruktionerna.
                        <br>
                        Att arbeta med ORM-verktyg kan vara effektivt och smidigt, men det kan också kännas som "magi" eftersom det abstraherar bort detaljerna i databasinteraktionerna.
                        <br>
                        Detta kan vara frustrerande för vissa som föredrar att ha full kontroll och förståelse över vad som händer i deras applikation.
                        <br>
                        Med traditionell MYSQL får man mer direkt kontroll och kan ha en klarare bild av exakt vad som sker i databasen.
                        <br><br>
                        Å andra sidan kan fördelarna med att använda ORM vara att det förenklar kodskrivning, sparar tid och minskar behovet av att manuellt hantera SQL-frågor och databasinteraktioner.
                        <br>
                        Det gör det också lättare att arbeta med olika databassystem utan att behöva ändra mycket i kodbasen.
                        <br><br>
                        Min uppfattning av ORM är att det gör det möjligt för programmeraren att hantera databasen på ett objektorienterat sätt.
                        <br><br>
                        MIN TIL för detta kursmoment är att jag fick lära mig vad ORM är och hur det fungerar. Samt fick jag träna på att använda Doctrine.
                    </p>
                </div>
                <div class="item" id="kmom06">
                    <h2>Kmom06</h2>
                    <p>
                        Under detta kursmoment har vi fått kunskap om användningen av verktygen Scrutinizer och phpMetrics, som båda är till hjälp vid automatiserad testning.
                        phpMetrics är ett kraftfullt verktyg som ger oss förmågan att analysera PHP-kod noggrant. Genom att generera rapporter om kodens komplexitet, underhållbarhet och kvalitet ger det oss en djupgående insikt i vår kodbas. Med hjälp av phpMetrics kan vi som utvecklare identifiera områden där vi kan förbättra kodkvaliteten och optimera prestandan i våra PHP-projekt. Det spelar en avgörande roll för att säkerställa att vår kod är robust, skalbar och följer bästa praxis inom PHP-utveckling.
                        En av de mest betydelsefulla funktionerna i phpMetrics, enligt min åsikt, är dess "violations"-rapport. Denna rapport ger oss möjligheten att identifiera eventuella överträdelser, varningar och fel i vår kod. 
                        Jag blev imponerad av hur snabbt och smidigt jag kunde integrera med Scrutinizer. Det var verkligen en enkel process. Jag anser att Scrutinizer är en oerhört viktig resurs och jag ser fram emot att använda den i kommande projekt. En av de aspekter jag verkligen uppskattar med Scrutinizer är dess förmåga att exakt visa var i koden eventuella fel kan finnas. Dessutom är det fantastiskt att det stöder flera olika programmeringsspråk. Det ger mig möjlighet att använda verktyget inte bara i PHP-projekt, utan också i andra utvecklingsprojekt.
                        Att utvärdera kodkvalitet är en betydelsefull process som kan vara till stor hjälp för utvecklare. Emellertid är det viktigt att vara medveten om att PhpMetrics och Scrutinizer inte alltid ger helt korrekta resultat, och därför krävs det försiktighet vid tolkning av deras utvärderingar. Det är inte nödvändigtvis rekommenderat att följa dessa verktyg till 100 procent, utan snarare att använda dem som en del av en helhetsbedömning av kodkvaliteten. Det är klokt att komplettera dessa verktyg med andra metoder och expertbedömningar för att få en mer fullständig och pålitlig uppfattning om kodens kvalitet och eventuella förbättringsområden.
                        Under detta kursmoment har jag lärt mig att använda Scrutinizer och phpMetrics för att förbättra kodkvaliteten. Genom att tillämpa de sex C:na - "Codestyle", "Coverage", "Complexity", "Cohesion", "Coupling" och "CRAP" - kan jag skapa en mer perfekt och välskött kodstruktur med minskad risk för buggar och fel.

                    </p>
                </div>
                <div class="item" id="kmom10">
                    <h2>Kmom10</h2>
                    <p>
                        I kmom 10 (projekt) valde jag att skapa ett spel baserat på skitgubbe. Jag kände att det fanns en brist på skitgubbespel på internet, vilket motiverade mig att bygga det själv. Trots att jag letade efter inspirationer, lyckades jag inte hitta något som passade min vision.<br><br>
                        Jag har lagt ner mycket tid på att skapa en unik och attraktiv stil för spelets webbplats. Stilen skiljer sig helt från en vanlig rapportwebbplats. Jag har valt olika färger och designat korten samt deras placeringar för att ge en realistisk känsla. Mer information om spelet finns tillgänglig på /proj/about.<br><br>
                        För att underlätta för dem som vill klona och testa projektet har jag lagt till detaljerade instruktioner på GitHub i filen README.md. I README.md finns även klickbara badges från Scrutinizer som leder till rapporter för byggstatus, kodtäckning och kodkvalitet.<br><br>
                        Jag har lagt stor vikt vid att kommentera och dokumentera min kod genom att använda phpdoc-standard. Dessutom har jag uppnått en kodtäckning på över 95% och genererat metrics med hjälp av phpmetrics.<br><br><br>
                        <h3>JSON API</h3>
                        Faktum är att jag valde att börja projektet med att utveckla ett JSON API eftersom jag tyckte att det var enklare att komma i gång och fokusera mer på själva logiken i koden. Spelet är fullt fungerande tack vare API:et.<br><br>
                        Efter att jag avslutade arbetet med API:et insåg jag att det skulle finnas samma kod i både API-kontrollern och webbgränssnittets kontroller. För att lösa detta problem skapade jag ett trait som både API-kontrollern och webbgränssnittets kontroller kan använda. Detta tillvägagångssätt gör min kod DRY (Don't Repeat Yourself). Genom att använda traitet kan jag undvika onödig duplicering och effektivisera kodhanteringen.<br><br>
                        För att underlätta för er har jag inkluderat länkar som gör det lättare att testa API:et och se dess funktionalitet.<br><br><br>
                        <h3>ORM</h3>
                        För att implementera ett autentiseringssystem för användarna och möjliggöra lagring av deras resultat, använde jag mig av Doctrine tillsammans med SQLite som databas. Jag skapade två tabeller i databasen: en för resultat och en för användare.<br><br>
                        För mer info om implementationen för ORM gå gärna till proj/about/database<br><br>
                        Doctrine gör det enkelt att hantera och interagera med databasen. Det ger flexibilitet och bekvämlighet vid sparande och hämtning av data samt autentisering för användare. Nackdelarna med Doctrine inkluderar ibland komplexitet vid ändring av databasstrukturen och en förlorad känsla av full kontroll, vilket kan kännas nästan magiskt och är inte min grej. Att använda ett ORM-verktyg som Doctrine ger enkelhet och effektivitet genom objektorienterad programmering och arbetar med databasen som objekt och klasser. Det är dock viktigt att notera att ett ORM-verktyg som Doctrine kanske inte passar alla utvecklare och att vissa föredrar en mer direkt och hands-on approach. Valet av databashanteringsverktyg beror på individuella preferenser och projektets behov.<br><br><br>
                        <h3>Avancerade features</h3>
                        När jag bestämde mig för att programmera ett skitgubbespel, tänkte jag att det skulle vara mycket enkelt och att jag skulle kunna implementera det på mindre än 40 timmar enligt projektets instruktioner. Men det visade sig att det tog över 100 timmar, och vissa delar av spelet var mer avancerade och tidskrävande än jag hade förväntat mig.<br><br>
                        I början av spelet hade jag bara implementerat möjligheten att spelaren kunde slänga ett kort åt gången. Men när jag testade spelet insåg jag att spelarna också behövde kunna slänga flera kort av samma valör, till exempel om de hade två treor i handen. Detta blev ganska frustrerande och krävde mer tid att fixa. Jag hade inte tänkt på att när flera kort slängs behöver indexen för de återstående korten i handen uppdateras efter varje borttagning. Detta misstag ledde till många buggar, då andra kort försvann på fel sätt. Jag försökte lösa problemet med en algoritm, men det skapade bara fler buggar. Till slut kom jag på en enkel lösning: att sortera kortens index i fallande ordning. Genom att ta bort korten från högsta till lägsta index undvek jag att påverka kort med lägre index. Detta löste problemet helt och fixade de tidigare buggarna.<br><br>
                        Problemen begränsades inte bara till spelaren utan även till datorn. Jag hade programmerat datorn för att spela precis som jag tänkte att en skitgubbe skulle spela. Datorn började med att använda sina mindre kort först och sedan de större. Om datorn inte hade några större kort försökte den kolla om den hade tvåor eller tior. Om den hade det skulle den spela dem och slänga ytterligare ett mindre kort. Detta ledde också till många buggar, men jag lyckades lösa dem till slut.<br><br>
                        Jag hade också problem med att hantera situationen när spelarens hand var tom och kortleken också var slut. Enligt reglerna skulle spelaren då kunna använda de synliga korten på bordet, och om de var slut skulle spelaren kunna använda de osynliga korten. Detta skapade också en del buggar, men jag lyckades lösa dem till slut.<br><br>
                        Dessa problem var inte svåra att fixa och jag behövde ingen hjälp från andra, men de tog mycket tid i anspråk. Min största frustration var att det tog längre tid än jag hade förväntat mig.<br><br><br>

                        Projektet var oerhört spännande och jag har haft en fantastisk tid med att programmera det. Jag valde att skapa skitgubbespelet eftersom jag ville kunna spela det på datorn, men jag kunde inte hitta ett liknande projekt online. Som jag nämnde tidigare hade jag ingen aning om att det skulle ta så mycket tid, men jag inser att det är vanligt när man påbörjar ett projekt. Det har i alla fall varit min erfarenhet att man tror att det kommer att vara enkelt och att det inte kommer att ta så lång tid, men när man väl sätter i gång med projektet inser man att det inte är som man tänkt sig. Trots det har jag haft väldigt roligt med att genomföra det och har lärt mig massor av nya saker.<br><br><br>

                        Kursen var mycket lärorik och lärarna var mycket hjälpsamma. Dock hade kursen väldigt omfattande uppgifter, särskilt projektet. Det var verkligen stort. Det stod att det skulle ta mellan 20 och 40 timmar att genomföra, men det tog mig betydligt längre tid. Trots det är jag nöjd med kursen och skulle ge den 8 av 10 i betyg.<br><br><br>

                    </p>
                </div>
            </div>
        </div>
    </div>
{% endblock %}